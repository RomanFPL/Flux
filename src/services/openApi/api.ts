/* tslint:disable */
/* eslint-disable */
/**
 * Fleet.BackendAPI.WebAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
    DUMMY_BASE_URL,
    assertParamExists,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    serializeDataIfNeeded,
    toPathString,
    createRequestFunction
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from "./base";

/**
 *
 * @export
 * @enum {string}
 */

export const ActiveSecsGemStatus = {
    Offline: "Offline",
    NotExists: "NotExists",
    OnlineLocal: "OnlineLocal",
    OnlineRemote: "OnlineRemote"
} as const;

export type ActiveSecsGemStatus = (typeof ActiveSecsGemStatus)[keyof typeof ActiveSecsGemStatus];

/**
 *
 * @export
 * @enum {string}
 */

export const ActiveToolStatus = {
    Offline: "Offline",
    Engineering: "Engineering",
    Idle: "Idle",
    Production: "Production",
    Maitanance: "Maitanance",
    Breakdown: "Breakdown"
} as const;

export type ActiveToolStatus = (typeof ActiveToolStatus)[keyof typeof ActiveToolStatus];

/**
 *
 * @export
 * @interface Camera
 */
export interface Camera {
    /**
     *
     * @type {CameraType}
     * @memberof Camera
     */
    cameraType?: CameraType;
    /**
     *
     * @type {string}
     * @memberof Camera
     */
    name?: string | null;
    /**
     *
     * @type {Array<Light>}
     * @memberof Camera
     */
    lights?: Array<Light> | null;
}

/**
 *
 * @export
 * @enum {string}
 */

export const CameraType = {
    Sim: "SIM",
    LowMag: "LOW_MAG",
    HighMag: "HIGH_MAG",
    VeryhighMag: "VERYHIGH_MAG",
    Cts: "CTS",
    Stil: "STIL",
    Clip: "CLIP",
    Ir: "IR",
    Tdi: "TDI",
    IrScan: "IR_SCAN",
    Csp: "CSP"
} as const;

export type CameraType = (typeof CameraType)[keyof typeof CameraType];

/**
 *
 * @export
 * @interface DailyErrorCount
 */
export interface DailyErrorCount {
    /**
     *
     * @type {string}
     * @memberof DailyErrorCount
     */
    date?: string;
    /**
     *
     * @type {Array<ErrorCount>}
     * @memberof DailyErrorCount
     */
    errorsCount?: Array<ErrorCount> | null;
}
/**
 *
 * @export
 * @interface DataPoint
 */
export interface DataPoint {
    /**
     *
     * @type {string}
     * @memberof DataPoint
     */
    date?: string;
    /**
     *
     * @type {number}
     * @memberof DataPoint
     */
    value?: number;
}
/**
 *
 * @export
 * @interface ErrorCount
 */
export interface ErrorCount {
    /**
     *
     * @type {string}
     * @memberof ErrorCount
     */
    name?: string | null;
    /**
     *
     * @type {number}
     * @memberof ErrorCount
     */
    value?: number;
}
/**
 *
 * @export
 * @interface EventLogMessage
 */
export interface EventLogMessage {
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    context?: string | null;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    subContext?: string | null;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    source?: string | null;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    action?: string | null;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    actionResult?: string | null;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    eventDateTimeStr?: string | null;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    eventDateTime?: string;
    /**
     *
     * @type {Payload}
     * @memberof EventLogMessage
     */
    payload?: Payload;
    /**
     *
     * @type {EventSeverity}
     * @memberof EventLogMessage
     */
    severity?: EventSeverity;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    message?: string | null;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    callStack?: string | null;
    /**
     *
     * @type {string}
     * @memberof EventLogMessage
     */
    longMessage?: string | null;
}

/**
 *
 * @export
 * @enum {string}
 */

export const EventSeverity = {
    None: "None",
    Error: "Error",
    Warning: "Warning",
    All: "All"
} as const;

export type EventSeverity = (typeof EventSeverity)[keyof typeof EventSeverity];

/**
 *
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     *
     * @type {HealthStatusEnum}
     * @memberof HealthStatus
     */
    status?: HealthStatusEnum;
    /**
     *
     * @type {string}
     * @memberof HealthStatus
     */
    startTime?: string | null;
}

/**
 *
 * @export
 * @enum {string}
 */

export const HealthStatusEnum = {
    Up: "Up",
    Starting: "Starting",
    Down: "Down"
} as const;

export type HealthStatusEnum = (typeof HealthStatusEnum)[keyof typeof HealthStatusEnum];

/**
 *
 * @export
 * @interface Issue
 */
export interface Issue {
    /**
     *
     * @type {number}
     * @memberof Issue
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof Issue
     */
    toolID?: string | null;
    /**
     *
     * @type {string}
     * @memberof Issue
     */
    createdDate?: string;
    /**
     *
     * @type {string}
     * @memberof Issue
     */
    userName?: string | null;
    /**
     *
     * @type {string}
     * @memberof Issue
     */
    description?: string | null;
}
/**
 *
 * @export
 * @interface IssueAddOrUpdateRes
 */
export interface IssueAddOrUpdateRes {
    /**
     *
     * @type {boolean}
     * @memberof IssueAddOrUpdateRes
     */
    suceess?: boolean;
    /**
     *
     * @type {string}
     * @memberof IssueAddOrUpdateRes
     */
    message?: string | null;
    /**
     *
     * @type {Issue}
     * @memberof IssueAddOrUpdateRes
     */
    issue?: Issue;
}
/**
 *
 * @export
 * @interface Light
 */
export interface Light {
    /**
     *
     * @type {LightType}
     * @memberof Light
     */
    lightType?: LightType;
    /**
     *
     * @type {LightCategoryType}
     * @memberof Light
     */
    lightCategoryType?: LightCategoryType;
    /**
     *
     * @type {string}
     * @memberof Light
     */
    name?: string | null;
    /**
     *
     * @type {string}
     * @memberof Light
     */
    lastReplacementDate?: string;
    /**
     *
     * @type {LightLifeTimeUnits}
     * @memberof Light
     */
    lightLifeTimeUnits?: LightLifeTimeUnits;
    /**
     *
     * @type {number}
     * @memberof Light
     */
    maxLifeTime?: number;
    /**
     *
     * @type {number}
     * @memberof Light
     */
    currentLifeTime?: number;
    /**
     *
     * @type {number}
     * @memberof Light
     */
    recommendedReplacement?: number;
    /**
     *
     * @type {number}
     * @memberof Light
     */
    necessaryReplacement?: number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const LightCategoryType = {
    Unknown: "Unknown",
    Led: "LED",
    Halogen: "Halogen",
    Xenon: "Xenon"
} as const;

export type LightCategoryType = (typeof LightCategoryType)[keyof typeof LightCategoryType];

/**
 *
 * @export
 * @interface LightLCCDataPoints
 */
export interface LightLCCDataPoints {
    /**
     *
     * @type {string}
     * @memberof LightLCCDataPoints
     */
    lightName?: string | null;
    /**
     *
     * @type {Array<DataPoint>}
     * @memberof LightLCCDataPoints
     */
    dataPoints?: Array<DataPoint> | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const LightLifeTimeUnits = {
    Hours: "Hours",
    Flashes: "Flashes"
} as const;

export type LightLifeTimeUnits = (typeof LightLifeTimeUnits)[keyof typeof LightLifeTimeUnits];

/**
 *
 * @export
 * @interface LightReplacementPrediction
 */
export interface LightReplacementPrediction {
    /**
     *
     * @type {LightType}
     * @memberof LightReplacementPrediction
     */
    lightType?: LightType;
    /**
     *
     * @type {number}
     * @memberof LightReplacementPrediction
     */
    daysToReplacement?: number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const LightType = {
    Sim: "SIM",
    FlashRef: "FLASH_REF",
    FlashDif: "FLASH_DIF",
    VhmRef: "VHM_REF",
    VhmDiff: "VHM_DIFF",
    Ivp: "IVP",
    FlashBack: "FLASH_BACK",
    FlashDif2: "FLASH_DIF2",
    IrRef: "IR_REF",
    TdiRef: "TDI_REF",
    TdiDif: "TDI_DIF",
    IrScanRef: "IR_SCAN_REF",
    Csp: "CSP"
} as const;

export type LightType = (typeof LightType)[keyof typeof LightType];

/**
 *
 * @export
 * @enum {string}
 */

export const Lights = {
    Ref: "Ref",
    Def: "Def"
} as const;

export type Lights = (typeof Lights)[keyof typeof Lights];

/**
 *
 * @export
 * @interface MaintenanceTask
 */
export interface MaintenanceTask {
    /**
     *
     * @type {number}
     * @memberof MaintenanceTask
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof MaintenanceTask
     */
    toolID?: string | null;
    /**
     *
     * @type {string}
     * @memberof MaintenanceTask
     */
    createdDate?: string;
    /**
     *
     * @type {Array<WorkLog>}
     * @memberof MaintenanceTask
     */
    workLogs?: Array<WorkLog> | null;
    /**
     *
     * @type {boolean}
     * @memberof MaintenanceTask
     */
    partsReplaced?: boolean;
    /**
     *
     * @type {ServiceType}
     * @memberof MaintenanceTask
     */
    serviceType?: ServiceType;
    /**
     *
     * @type {PMSeverity}
     * @memberof MaintenanceTask
     */
    severity?: PMSeverity;
    /**
     *
     * @type {boolean}
     * @memberof MaintenanceTask
     */
    done?: boolean;
    /**
     *
     * @type {string}
     * @memberof MaintenanceTask
     */
    engineer?: string | null;
    /**
     *
     * @type {string}
     * @memberof MaintenanceTask
     */
    description?: string | null;
    /**
     *
     * @type {string}
     * @memberof MaintenanceTask
     */
    description2?: string | null;
    /**
     *
     * @type {string}
     * @memberof MaintenanceTask
     */
    actionTaken?: string | null;
    /**
     *
     * @type {string}
     * @memberof MaintenanceTask
     */
    notificationReference?: string | null;
}

/**
 *
 * @export
 * @interface MaintenanceTaskAddOrUpdateRes
 */
export interface MaintenanceTaskAddOrUpdateRes {
    /**
     *
     * @type {boolean}
     * @memberof MaintenanceTaskAddOrUpdateRes
     */
    suceess?: boolean;
    /**
     *
     * @type {string}
     * @memberof MaintenanceTaskAddOrUpdateRes
     */
    message?: string | null;
    /**
     *
     * @type {MaintenanceTask}
     * @memberof MaintenanceTaskAddOrUpdateRes
     */
    task?: MaintenanceTask;
}
/**
 *
 * @export
 * @interface OverallHealthStatus
 */
export interface OverallHealthStatus {
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    totalTools?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    toolsInProduction?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    toolsInMaintenance?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    toolsDown?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    alignmentErrors?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    scanErrors?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    scan2DErrors?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    scan3DErrors?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    killAOICount?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    alignmentErrorsMaxNormal?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    scanErrorsMaxNormal?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    scan2DErrorsMaxNormal?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    scan3DErrorsMaxNormal?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    killAOICountMaxNormal?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    toolsLightsExpiredCount?: number;
    /**
     *
     * @type {number}
     * @memberof OverallHealthStatus
     */
    highDegradationRateToolsCount?: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export const PMSeverity = {
    Normal: "Normal",
    High: "High"
} as const;

export type PMSeverity = (typeof PMSeverity)[keyof typeof PMSeverity];

/**
 *
 * @export
 * @interface Payload
 */
export interface Payload {
    /**
     *
     * @type {string}
     * @memberof Payload
     */
    typeName?: string | null;
    /**
     *
     * @type {string}
     * @memberof Payload
     */
    data?: string | null;
}
/**
 *
 * @export
 * @interface PreferencesState
 */
export interface PreferencesState {
    /**
     *
     * @type {string}
     * @memberof PreferencesState
     */
    value?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ServiceType = {
    Pm: "PM",
    Regular: "Regular",
    Service: "Service",
    Application: "Application"
} as const;

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType];

/**
 *
 * @export
 * @interface ShortLogMessage
 */
export interface ShortLogMessage {
    /**
     *
     * @type {string}
     * @memberof ShortLogMessage
     */
    eventDateTime?: string;
    /**
     *
     * @type {EventSeverity}
     * @memberof ShortLogMessage
     */
    severity?: EventSeverity;
    /**
     *
     * @type {string}
     * @memberof ShortLogMessage
     */
    message?: string | null;
    /**
     *
     * @type {string}
     * @memberof ShortLogMessage
     */
    longMessage?: string | null;
}

/**
 *
 * @export
 * @interface ShortNotifications
 */
export interface ShortNotifications {
    /**
     *
     * @type {boolean}
     * @memberof ShortNotifications
     */
    periodicCalibIsForcesSkipped?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ShortNotifications
     */
    motionByPassOn?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ShortNotifications
     */
    axisConstrainsNotFound?: boolean;
}
/**
 *
 * @export
 * @interface ToolDataPoints
 */
export interface ToolDataPoints {
    /**
     *
     * @type {string}
     * @memberof ToolDataPoints
     */
    toolID?: string | null;
    /**
     *
     * @type {Array<DataPoint>}
     * @memberof ToolDataPoints
     */
    dataPoints?: Array<DataPoint> | null;
}
/**
 *
 * @export
 * @interface ToolIdentity
 */
export interface ToolIdentity {
    /**
     *
     * @type {string}
     * @memberof ToolIdentity
     */
    toolId?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolIdentity
     */
    machineName?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolIdentity
     */
    ip?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolIdentity
     */
    apiAddress?: string | null;
}
/**
 *
 * @export
 * @interface ToolInfo
 */
export interface ToolInfo {
    /**
     *
     * @type {ToolIdentity}
     * @memberof ToolInfo
     */
    identity?: ToolIdentity;
    /**
     *
     * @type {Array<Camera>}
     * @memberof ToolInfo
     */
    cameras?: Array<Camera> | null;
    /**
     *
     * @type {ToolStatus}
     * @memberof ToolInfo
     */
    toolStatus?: ToolStatus;
    /**
     *
     * @type {XYTableType}
     * @memberof ToolInfo
     */
    chuckType?: XYTableType;
    /**
     *
     * @type {string}
     * @memberof ToolInfo
     */
    nextPMDate?: string;
    /**
     *
     * @type {ShortNotifications}
     * @memberof ToolInfo
     */
    shortNotifications?: ShortNotifications;
}

/**
 *
 * @export
 * @interface ToolInfoStatus
 */
export interface ToolInfoStatus {
    /**
     *
     * @type {ToolIdentity}
     * @memberof ToolInfoStatus
     */
    identity?: ToolIdentity;
    /**
     *
     * @type {ToolStatus}
     * @memberof ToolInfoStatus
     */
    toolStatus?: ToolStatus;
}
/**
 *
 * @export
 * @interface ToolLogMessage
 */
export interface ToolLogMessage {
    /**
     *
     * @type {string}
     * @memberof ToolLogMessage
     */
    toolID?: string | null;
    /**
     *
     * @type {ShortLogMessage}
     * @memberof ToolLogMessage
     */
    log?: ShortLogMessage;
}
/**
 *
 * @export
 * @interface ToolStatus
 */
export interface ToolStatus {
    /**
     *
     * @type {string}
     * @memberof ToolStatus
     */
    toolId?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolStatus
     */
    falconVersion?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolStatus
     */
    cmmVersion?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof ToolStatus
     */
    falconRunning?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ToolStatus
     */
    stageMappingEnabled?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ToolStatus
     */
    lccPeriodicExist?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ToolStatus
     */
    toolMatchEnabled?: boolean;
    /**
     *
     * @type {ActiveToolStatus}
     * @memberof ToolStatus
     */
    activeToolStatus?: ActiveToolStatus;
    /**
     *
     * @type {ActiveSecsGemStatus}
     * @memberof ToolStatus
     */
    activeSecsGemStatus?: ActiveSecsGemStatus;
    /**
     *
     * @type {ShortLogMessage}
     * @memberof ToolStatus
     */
    lastLogMessage?: ShortLogMessage;
    /**
     *
     * @type {string}
     * @memberof ToolStatus
     */
    loginName?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolStatus
     */
    backupSystemLocation?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolStatus
     */
    environment?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolStatus
     */
    activeToolStatusText?: string | null;
    /**
     *
     * @type {string}
     * @memberof ToolStatus
     */
    activeSecsGemStatusText?: string | null;
}

/**
 *
 * @export
 * @interface ToolsDataPointsData
 */
export interface ToolsDataPointsData {
    /**
     *
     * @type {Array<ToolDataPoints>}
     * @memberof ToolsDataPointsData
     */
    toolDataPoints?: Array<ToolDataPoints> | null;
    /**
     *
     * @type {Array<DataPoint>}
     * @memberof ToolsDataPointsData
     */
    average?: Array<DataPoint> | null;
}
/**
 *
 * @export
 * @interface UserPreferencesState
 */
export interface UserPreferencesState {
    /**
     *
     * @type {number}
     * @memberof UserPreferencesState
     */
    userID?: number;
    /**
     *
     * @type {PreferencesState}
     * @memberof UserPreferencesState
     */
    value?: PreferencesState;
}
/**
 *
 * @export
 * @interface WorkLog
 */
export interface WorkLog {
    /**
     *
     * @type {string}
     * @memberof WorkLog
     */
    startDate?: string;
    /**
     *
     * @type {number}
     * @memberof WorkLog
     */
    durationHours?: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export const XYTableType = {
    NotExist: "NotExist",
    Simulator: "Simulator",
    Camtek: "Camtek",
    Bare6to12: "Bare_6to12",
    PdBare4to12: "PdBare_4to12",
    _12PdBareTaiko: "_12PdBareTaiko",
    _12PdBareTaikoDualReg: "_12PdBareTaikoDualReg",
    WarpedWafers812: "WarpedWafers_8_12",
    PdBare812NoReg: "PdBare_8_12_NoReg",
    Bare468BlackPorous: "Bare_4_6_8_BlackPorous",
    Bare66Ebr8: "Bare_6_6EBR_8",
    _12Bare12PdRotate: "_12Bare_12PdRotate",
    PdBare812Clamper: "PdBare_8_12_Clamper",
    Bare12LowContact: "Bare_12_LowContact",
    PdBare4to12NoReg: "PdBare_4to12_NoReg",
    Panel: "Panel",
    BackLightPd812: "BackLightPD_8_12",
    Bare4to12WithOutPins: "Bare_4to12_WithOutPins",
    PdBare812NoRegBosh: "PdBare_8_12_NoReg_Bosh",
    Bare12Square: "Bare_12_Square",
    Bare12Groove: "Bare_12_Groove",
    Bare12Warped: "Bare_12_Warped",
    PdBareHoop12: "PdBareHoop_12",
    AseReflectorWarped12: "ASEReflectorWarped_12",
    HawkDeprecated: "Hawk__deprecated",
    _12PdBareTaikoNoReg: "_12PdBareTaikoNoReg",
    Pd812: "PD_8_12",
    Bare346812: "Bare_3_4_6_8_12",
    Hawk: "Hawk",
    Jedec: "JEDEC",
    PdBare4to12BowNo6Pd: "PdBare_4to12BOW_NO_6PD",
    Reuse: "__reuse__",
    WarpedNipples812: "WarpedNipples_8_12",
    PdBare812Warped: "PdBare_8_12_Warped",
    Selective812Warped: "Selective_8_12_Warped",
    BackLightMetrology: "BackLightMetrology"
} as const;

export type XYTableType = (typeof XYTableType)[keyof typeof XYTableType];

/**
 * GraphDataApi - axios parameter creator
 * @export
 */
export const GraphDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary AOI Statistics, errors statistics data
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphdataAoistatisticsStartdateEnddateToolidsGet: async (
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists("graphdataAoistatisticsStartdateEnddateToolidsGet", "startDate", startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists("graphdataAoistatisticsStartdateEnddateToolidsGet", "endDate", endDate);
            const localVarPath = `/graphdata/aoistatistics/{startdate}/{enddate}/{toolids}`
                .replace(`{${"startDate"}}`, encodeURIComponent(String(startDate)))
                .replace(`{${"endDate"}}`, encodeURIComponent(String(endDate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (toolids) {
                localVarQueryParameter["toolids"] = toolids;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary LCC data
         * @param {string} toolid
         * @param {Lights} lightType
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphdataLccToolidLightTypeStartdateEnddateGet: async (
            toolid: string,
            lightType: Lights,
            startDate: string,
            endDate: string,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'toolid' is not null or undefined
            assertParamExists("graphdataLccToolidLightTypeStartdateEnddateGet", "toolid", toolid);
            // verify required parameter 'lightType' is not null or undefined
            assertParamExists("graphdataLccToolidLightTypeStartdateEnddateGet", "lightType", lightType);
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists("graphdataLccToolidLightTypeStartdateEnddateGet", "startDate", startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists("graphdataLccToolidLightTypeStartdateEnddateGet", "endDate", endDate);
            const localVarPath = `/graphdata/lcc/{toolid}/{lightType}/{startdate}/{enddate}`
                .replace(`{${"toolid"}}`, encodeURIComponent(String(toolid)))
                .replace(`{${"lightType"}}`, encodeURIComponent(String(lightType)))
                .replace(`{${"startDate"}}`, encodeURIComponent(String(startDate)))
                .replace(`{${"endDate"}}`, encodeURIComponent(String(endDate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get throughput data, wafer per hour
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [worstToolsCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphdataTptStartdateEnddateToolidsGet: async (
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            worstToolsCount?: number,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists("graphdataTptStartdateEnddateToolidsGet", "startDate", startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists("graphdataTptStartdateEnddateToolidsGet", "endDate", endDate);
            const localVarPath = `/graphdata/tpt/{startdate}/{enddate}/{toolids}`
                .replace(`{${"startDate"}}`, encodeURIComponent(String(startDate)))
                .replace(`{${"endDate"}}`, encodeURIComponent(String(endDate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (toolids) {
                localVarQueryParameter["toolids"] = toolids;
            }

            if (worstToolsCount !== undefined) {
                localVarQueryParameter["worstToolsCount"] = worstToolsCount;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get yield data
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [worstToolsCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphdataYieldStartdateEnddateToolidsGet: async (
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            worstToolsCount?: number,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists("graphdataYieldStartdateEnddateToolidsGet", "startDate", startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists("graphdataYieldStartdateEnddateToolidsGet", "endDate", endDate);
            const localVarPath = `/graphdata/yield/{startdate}/{enddate}/{toolids}`
                .replace(`{${"startDate"}}`, encodeURIComponent(String(startDate)))
                .replace(`{${"endDate"}}`, encodeURIComponent(String(endDate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (toolids) {
                localVarQueryParameter["toolids"] = toolids;
            }

            if (worstToolsCount !== undefined) {
                localVarQueryParameter["worstToolsCount"] = worstToolsCount;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * GraphDataApi - functional programming interface
 * @export
 */
export const GraphDataApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphDataApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary AOI Statistics, errors statistics data
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async graphdataAoistatisticsStartdateEnddateToolidsGet(
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DailyErrorCount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.graphdataAoistatisticsStartdateEnddateToolidsGet(
                startDate,
                endDate,
                toolids,
                options
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["GraphDataApi.graphdataAoistatisticsStartdateEnddateToolidsGet"]?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary LCC data
         * @param {string} toolid
         * @param {Lights} lightType
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async graphdataLccToolidLightTypeStartdateEnddateGet(
            toolid: string,
            lightType: Lights,
            startDate: string,
            endDate: string,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LightLCCDataPoints>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.graphdataLccToolidLightTypeStartdateEnddateGet(
                toolid,
                lightType,
                startDate,
                endDate,
                options
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["GraphDataApi.graphdataLccToolidLightTypeStartdateEnddateGet"]?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get throughput data, wafer per hour
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [worstToolsCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async graphdataTptStartdateEnddateToolidsGet(
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            worstToolsCount?: number,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsDataPointsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.graphdataTptStartdateEnddateToolidsGet(
                startDate,
                endDate,
                toolids,
                worstToolsCount,
                options
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["GraphDataApi.graphdataTptStartdateEnddateToolidsGet"]?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get yield data
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [worstToolsCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async graphdataYieldStartdateEnddateToolidsGet(
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            worstToolsCount?: number,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsDataPointsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.graphdataYieldStartdateEnddateToolidsGet(
                startDate,
                endDate,
                toolids,
                worstToolsCount,
                options
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["GraphDataApi.graphdataYieldStartdateEnddateToolidsGet"]?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * GraphDataApi - factory interface
 * @export
 */
export const GraphDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphDataApiFp(configuration);
    return {
        /**
         *
         * @summary AOI Statistics, errors statistics data
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphdataAoistatisticsStartdateEnddateToolidsGet(
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<Array<DailyErrorCount>> {
            return localVarFp
                .graphdataAoistatisticsStartdateEnddateToolidsGet(startDate, endDate, toolids, options)
                .then(request => request(axios, basePath));
        },
        /**
         *
         * @summary LCC data
         * @param {string} toolid
         * @param {Lights} lightType
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphdataLccToolidLightTypeStartdateEnddateGet(
            toolid: string,
            lightType: Lights,
            startDate: string,
            endDate: string,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<Array<LightLCCDataPoints>> {
            return localVarFp
                .graphdataLccToolidLightTypeStartdateEnddateGet(toolid, lightType, startDate, endDate, options)
                .then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Get throughput data, wafer per hour
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [worstToolsCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphdataTptStartdateEnddateToolidsGet(
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            worstToolsCount?: number,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<ToolsDataPointsData> {
            return localVarFp
                .graphdataTptStartdateEnddateToolidsGet(startDate, endDate, toolids, worstToolsCount, options)
                .then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Get yield data
         * @param {string} startDate
         * @param {string} endDate
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [worstToolsCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphdataYieldStartdateEnddateToolidsGet(
            startDate: string,
            endDate: string,
            toolids?: Array<string>,
            worstToolsCount?: number,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<ToolsDataPointsData> {
            return localVarFp
                .graphdataYieldStartdateEnddateToolidsGet(startDate, endDate, toolids, worstToolsCount, options)
                .then(request => request(axios, basePath));
        }
    };
};

/**
 * GraphDataApi - object-oriented interface
 * @export
 * @class GraphDataApi
 * @extends {BaseAPI}
 */
export class GraphDataApi extends BaseAPI {
    /**
     *
     * @summary AOI Statistics, errors statistics data
     * @param {string} startDate
     * @param {string} endDate
     * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphDataApi
     */
    public graphdataAoistatisticsStartdateEnddateToolidsGet(
        startDate: string,
        endDate: string,
        toolids?: Array<string>,
        options?: RawAxiosRequestConfig
    ) {
        return GraphDataApiFp(this.configuration)
            .graphdataAoistatisticsStartdateEnddateToolidsGet(startDate, endDate, toolids, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary LCC data
     * @param {string} toolid
     * @param {Lights} lightType
     * @param {string} startDate
     * @param {string} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphDataApi
     */
    public graphdataLccToolidLightTypeStartdateEnddateGet(
        toolid: string,
        lightType: Lights,
        startDate: string,
        endDate: string,
        options?: RawAxiosRequestConfig
    ) {
        return GraphDataApiFp(this.configuration)
            .graphdataLccToolidLightTypeStartdateEnddateGet(toolid, lightType, startDate, endDate, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get throughput data, wafer per hour
     * @param {string} startDate
     * @param {string} endDate
     * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
     * @param {number} [worstToolsCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphDataApi
     */
    public graphdataTptStartdateEnddateToolidsGet(
        startDate: string,
        endDate: string,
        toolids?: Array<string>,
        worstToolsCount?: number,
        options?: RawAxiosRequestConfig
    ) {
        return GraphDataApiFp(this.configuration)
            .graphdataTptStartdateEnddateToolidsGet(startDate, endDate, toolids, worstToolsCount, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get yield data
     * @param {string} startDate
     * @param {string} endDate
     * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
     * @param {number} [worstToolsCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphDataApi
     */
    public graphdataYieldStartdateEnddateToolidsGet(
        startDate: string,
        endDate: string,
        toolids?: Array<string>,
        worstToolsCount?: number,
        options?: RawAxiosRequestConfig
    ) {
        return GraphDataApiFp(this.configuration)
            .graphdataYieldStartdateEnddateToolidsGet(startDate, endDate, toolids, worstToolsCount, options)
            .then(request => request(this.axios, this.basePath));
    }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get overall health status for all tools
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthStartdateEnddateGet: async (
            startDate: string,
            endDate: string,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists("healthStartdateEnddateGet", "startDate", startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists("healthStartdateEnddateGet", "endDate", endDate);
            const localVarPath = `/health/{startdate}/{enddate}`
                .replace(`{${"startDate"}}`, encodeURIComponent(String(startDate)))
                .replace(`{${"endDate"}}`, encodeURIComponent(String(endDate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get overall health status for all tools
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthStartdateEnddateGet(
            startDate: string,
            endDate: string,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverallHealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthStartdateEnddateGet(
                startDate,
                endDate,
                options
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["HealthApi.healthStartdateEnddateGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration);
    return {
        /**
         *
         * @summary Get overall health status for all tools
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthStartdateEnddateGet(
            startDate: string,
            endDate: string,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<OverallHealthStatus> {
            return localVarFp
                .healthStartdateEnddateGet(startDate, endDate, options)
                .then(request => request(axios, basePath));
        }
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     *
     * @summary Get overall health status for all tools
     * @param {string} startDate
     * @param {string} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthStartdateEnddateGet(startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration)
            .healthStartdateEnddateGet(startDate, endDate, options)
            .then(request => request(this.axios, this.basePath));
    }
}

/**
 * HeartBeatApi - axios parameter creator
 * @export
 */
export const HeartBeatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get Health status of the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/heartbeat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * HeartBeatApi - functional programming interface
 * @export
 */
export const HeartBeatApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = HeartBeatApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get Health status of the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heartbeatGet(
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heartbeatGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["HeartBeatApi.heartbeatGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * HeartBeatApi - factory interface
 * @export
 */
export const HeartBeatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HeartBeatApiFp(configuration);
    return {
        /**
         *
         * @summary Get Health status of the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.heartbeatGet(options).then(request => request(axios, basePath));
        }
    };
};

/**
 * HeartBeatApi - object-oriented interface
 * @export
 * @class HeartBeatApi
 * @extends {BaseAPI}
 */
export class HeartBeatApi extends BaseAPI {
    /**
     *
     * @summary Get Health status of the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartBeatApi
     */
    public heartbeatGet(options?: RawAxiosRequestConfig) {
        return HeartBeatApiFp(this.configuration)
            .heartbeatGet(options)
            .then(request => request(this.axios, this.basePath));
    }
}

/**
 * IssuesApi - axios parameter creator
 * @export
 */
export const IssuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete issue
         * @param {number} issueid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesIssueidDelete: async (issueid: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'issueid' is not null or undefined
            assertParamExists("issuesIssueidDelete", "issueid", issueid);
            const localVarPath = `/issues/{issueid}`.replace(`{${"issueid"}}`, encodeURIComponent(String(issueid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Add Or Update issue
         * @param {Issue} [issue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesPost: async (issue?: Issue, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(issue, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get issues for specific tool
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesToolidGet: async (toolid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolid' is not null or undefined
            assertParamExists("issuesToolidGet", "toolid", toolid);
            const localVarPath = `/issues/{toolid}`.replace(`{${"toolid"}}`, encodeURIComponent(String(toolid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * IssuesApi - functional programming interface
 * @export
 */
export const IssuesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = IssuesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Delete issue
         * @param {number} issueid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuesIssueidDelete(
            issueid: number,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuesIssueidDelete(issueid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["IssuesApi.issuesIssueidDelete"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Add Or Update issue
         * @param {Issue} [issue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuesPost(
            issue?: Issue,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueAddOrUpdateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuesPost(issue, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["IssuesApi.issuesPost"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get issues for specific tool
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuesToolidGet(
            toolid: string,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuesToolidGet(toolid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["IssuesApi.issuesToolidGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * IssuesApi - factory interface
 * @export
 */
export const IssuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssuesApiFp(configuration);
    return {
        /**
         *
         * @summary Delete issue
         * @param {number} issueid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesIssueidDelete(issueid: number, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.issuesIssueidDelete(issueid, options).then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Add Or Update issue
         * @param {Issue} [issue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesPost(issue?: Issue, options?: RawAxiosRequestConfig): AxiosPromise<IssueAddOrUpdateRes> {
            return localVarFp.issuesPost(issue, options).then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Get issues for specific tool
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesToolidGet(toolid: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Issue>> {
            return localVarFp.issuesToolidGet(toolid, options).then(request => request(axios, basePath));
        }
    };
};

/**
 * IssuesApi - object-oriented interface
 * @export
 * @class IssuesApi
 * @extends {BaseAPI}
 */
export class IssuesApi extends BaseAPI {
    /**
     *
     * @summary Delete issue
     * @param {number} issueid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public issuesIssueidDelete(issueid: number, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration)
            .issuesIssueidDelete(issueid, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Add Or Update issue
     * @param {Issue} [issue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public issuesPost(issue?: Issue, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration)
            .issuesPost(issue, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get issues for specific tool
     * @param {string} toolid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public issuesToolidGet(toolid: string, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration)
            .issuesToolidGet(toolid, options)
            .then(request => request(this.axios, this.basePath));
    }
}

/**
 * MaintenanceTasksApi - axios parameter creator
 * @export
 */
export const MaintenanceTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add Or Update Maintenance Task
         * @param {MaintenanceTask} [maintenanceTask]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mptasksPost: async (
            maintenanceTask?: MaintenanceTask,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            const localVarPath = `/mptasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(maintenanceTask, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Delete Maintenance Task
         * @param {number} taskid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mptasksTaskidDelete: async (taskid: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskid' is not null or undefined
            assertParamExists("mptasksTaskidDelete", "taskid", taskid);
            const localVarPath = `/mptasks/{taskid}`.replace(`{${"taskid"}}`, encodeURIComponent(String(taskid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get maintenance tasks for specific tool
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mptasksToolidGet: async (toolid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolid' is not null or undefined
            assertParamExists("mptasksToolidGet", "toolid", toolid);
            const localVarPath = `/mptasks/{toolid}`.replace(`{${"toolid"}}`, encodeURIComponent(String(toolid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * MaintenanceTasksApi - functional programming interface
 * @export
 */
export const MaintenanceTasksApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MaintenanceTasksApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Add Or Update Maintenance Task
         * @param {MaintenanceTask} [maintenanceTask]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mptasksPost(
            maintenanceTask?: MaintenanceTask,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceTaskAddOrUpdateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mptasksPost(maintenanceTask, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["MaintenanceTasksApi.mptasksPost"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete Maintenance Task
         * @param {number} taskid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mptasksTaskidDelete(
            taskid: number,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mptasksTaskidDelete(taskid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["MaintenanceTasksApi.mptasksTaskidDelete"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get maintenance tasks for specific tool
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mptasksToolidGet(
            toolid: string,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintenanceTask>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mptasksToolidGet(toolid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["MaintenanceTasksApi.mptasksToolidGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * MaintenanceTasksApi - factory interface
 * @export
 */
export const MaintenanceTasksApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance
) {
    const localVarFp = MaintenanceTasksApiFp(configuration);
    return {
        /**
         *
         * @summary Add Or Update Maintenance Task
         * @param {MaintenanceTask} [maintenanceTask]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mptasksPost(
            maintenanceTask?: MaintenanceTask,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<MaintenanceTaskAddOrUpdateRes> {
            return localVarFp.mptasksPost(maintenanceTask, options).then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Maintenance Task
         * @param {number} taskid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mptasksTaskidDelete(taskid: number, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.mptasksTaskidDelete(taskid, options).then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Get maintenance tasks for specific tool
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mptasksToolidGet(toolid: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MaintenanceTask>> {
            return localVarFp.mptasksToolidGet(toolid, options).then(request => request(axios, basePath));
        }
    };
};

/**
 * MaintenanceTasksApi - object-oriented interface
 * @export
 * @class MaintenanceTasksApi
 * @extends {BaseAPI}
 */
export class MaintenanceTasksApi extends BaseAPI {
    /**
     *
     * @summary Add Or Update Maintenance Task
     * @param {MaintenanceTask} [maintenanceTask]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceTasksApi
     */
    public mptasksPost(maintenanceTask?: MaintenanceTask, options?: RawAxiosRequestConfig) {
        return MaintenanceTasksApiFp(this.configuration)
            .mptasksPost(maintenanceTask, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete Maintenance Task
     * @param {number} taskid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceTasksApi
     */
    public mptasksTaskidDelete(taskid: number, options?: RawAxiosRequestConfig) {
        return MaintenanceTasksApiFp(this.configuration)
            .mptasksTaskidDelete(taskid, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get maintenance tasks for specific tool
     * @param {string} toolid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceTasksApi
     */
    public mptasksToolidGet(toolid: string, options?: RawAxiosRequestConfig) {
        return MaintenanceTasksApiFp(this.configuration)
            .mptasksToolidGet(toolid, options)
            .then(request => request(this.axios, this.basePath));
    }
}

/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get list of last log messages
         * @param {string} startDate
         * @param {string} endDate
         * @param {EventSeverity} severity
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logmessagesToolidsStartdateEnddateSeverityGet: async (
            startDate: string,
            endDate: string,
            severity: EventSeverity,
            toolids?: Array<string>,
            limit?: number,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists("logmessagesToolidsStartdateEnddateSeverityGet", "startDate", startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists("logmessagesToolidsStartdateEnddateSeverityGet", "endDate", endDate);
            // verify required parameter 'severity' is not null or undefined
            assertParamExists("logmessagesToolidsStartdateEnddateSeverityGet", "severity", severity);
            const localVarPath = `/logmessages/{toolids}/{startdate}/{enddate}/{severity}`
                .replace(`{${"startDate"}}`, encodeURIComponent(String(startDate)))
                .replace(`{${"endDate"}}`, encodeURIComponent(String(endDate)))
                .replace(`{${"severity"}}`, encodeURIComponent(String(severity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (toolids) {
                localVarQueryParameter["toolids"] = toolids;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get list of last log messages
         * @param {string} startDate
         * @param {string} endDate
         * @param {EventSeverity} severity
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logmessagesToolidsStartdateEnddateSeverityGet(
            startDate: string,
            endDate: string,
            severity: EventSeverity,
            toolids?: Array<string>,
            limit?: number,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ToolLogMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logmessagesToolidsStartdateEnddateSeverityGet(
                startDate,
                endDate,
                severity,
                toolids,
                limit,
                options
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["MessagesApi.logmessagesToolidsStartdateEnddateSeverityGet"]?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration);
    return {
        /**
         *
         * @summary Get list of last log messages
         * @param {string} startDate
         * @param {string} endDate
         * @param {EventSeverity} severity
         * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logmessagesToolidsStartdateEnddateSeverityGet(
            startDate: string,
            endDate: string,
            severity: EventSeverity,
            toolids?: Array<string>,
            limit?: number,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<Array<ToolLogMessage>> {
            return localVarFp
                .logmessagesToolidsStartdateEnddateSeverityGet(startDate, endDate, severity, toolids, limit, options)
                .then(request => request(axios, basePath));
        }
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     *
     * @summary Get list of last log messages
     * @param {string} startDate
     * @param {string} endDate
     * @param {EventSeverity} severity
     * @param {Array<string>} [toolids] Comma separated list of tool ids, empty collection will retrieve all tools
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public logmessagesToolidsStartdateEnddateSeverityGet(
        startDate: string,
        endDate: string,
        severity: EventSeverity,
        toolids?: Array<string>,
        limit?: number,
        options?: RawAxiosRequestConfig
    ) {
        return MessagesApiFp(this.configuration)
            .logmessagesToolidsStartdateEnddateSeverityGet(startDate, endDate, severity, toolids, limit, options)
            .then(request => request(this.axios, this.basePath));
    }
}

/**
 * PredictionsApi - axios parameter creator
 * @export
 */
export const PredictionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get Lights Replacement Prediction
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictLightsReplaceToolidGet: async (
            toolid: string,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'toolid' is not null or undefined
            assertParamExists("predictLightsReplaceToolidGet", "toolid", toolid);
            const localVarPath = `/predict/lights-replace/{toolid}`.replace(
                `{${"toolid"}}`,
                encodeURIComponent(String(toolid))
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * PredictionsApi - functional programming interface
 * @export
 */
export const PredictionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PredictionsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get Lights Replacement Prediction
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictLightsReplaceToolidGet(
            toolid: string,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LightReplacementPrediction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictLightsReplaceToolidGet(toolid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["PredictionsApi.predictLightsReplaceToolidGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * PredictionsApi - factory interface
 * @export
 */
export const PredictionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance
) {
    const localVarFp = PredictionsApiFp(configuration);
    return {
        /**
         *
         * @summary Get Lights Replacement Prediction
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictLightsReplaceToolidGet(
            toolid: string,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<Array<LightReplacementPrediction>> {
            return localVarFp.predictLightsReplaceToolidGet(toolid, options).then(request => request(axios, basePath));
        }
    };
};

/**
 * PredictionsApi - object-oriented interface
 * @export
 * @class PredictionsApi
 * @extends {BaseAPI}
 */
export class PredictionsApi extends BaseAPI {
    /**
     *
     * @summary Get Lights Replacement Prediction
     * @param {string} toolid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictionsApi
     */
    public predictLightsReplaceToolidGet(toolid: string, options?: RawAxiosRequestConfig) {
        return PredictionsApiFp(this.configuration)
            .predictLightsReplaceToolidGet(toolid, options)
            .then(request => request(this.axios, this.basePath));
    }
}

/**
 * ToolsApi - axios parameter creator
 * @export
 */
export const ToolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get list of all available tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get list of all available tools with statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsInfostatusesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools/infostatuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get tools statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsStatusesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get tool status
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsStatusesToolidGet: async (toolid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolid' is not null or undefined
            assertParamExists("toolsStatusesToolidGet", "toolid", toolid);
            const localVarPath = `/tools/statuses/{toolid}`.replace(
                `{${"toolid"}}`,
                encodeURIComponent(String(toolid))
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get tool extendeed info
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsToolidGet: async (toolid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolid' is not null or undefined
            assertParamExists("toolsToolidGet", "toolid", toolid);
            const localVarPath = `/tools/{toolid}`.replace(`{${"toolid"}}`, encodeURIComponent(String(toolid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * ToolsApi - functional programming interface
 * @export
 */
export const ToolsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ToolsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get list of all available tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsGet(
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ToolIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["ToolsApi.toolsGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get list of all available tools with statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsInfostatusesGet(
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ToolInfoStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsInfostatusesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["ToolsApi.toolsInfostatusesGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get tools statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsStatusesGet(
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ToolStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsStatusesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["ToolsApi.toolsStatusesGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get tool status
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsStatusesToolidGet(
            toolid: string,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsStatusesToolidGet(toolid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["ToolsApi.toolsStatusesToolidGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get tool extendeed info
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsToolidGet(
            toolid: string,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsToolidGet(toolid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["ToolsApi.toolsToolidGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * ToolsApi - factory interface
 * @export
 */
export const ToolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ToolsApiFp(configuration);
    return {
        /**
         *
         * @summary Get list of all available tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolIdentity>> {
            return localVarFp.toolsGet(options).then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Get list of all available tools with statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsInfostatusesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolInfoStatus>> {
            return localVarFp.toolsInfostatusesGet(options).then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Get tools statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsStatusesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolStatus>> {
            return localVarFp.toolsStatusesGet(options).then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Get tool status
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsStatusesToolidGet(toolid: string, options?: RawAxiosRequestConfig): AxiosPromise<ToolStatus> {
            return localVarFp.toolsStatusesToolidGet(toolid, options).then(request => request(axios, basePath));
        },
        /**
         *
         * @summary Get tool extendeed info
         * @param {string} toolid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsToolidGet(toolid: string, options?: RawAxiosRequestConfig): AxiosPromise<ToolInfo> {
            return localVarFp.toolsToolidGet(toolid, options).then(request => request(axios, basePath));
        }
    };
};

/**
 * ToolsApi - object-oriented interface
 * @export
 * @class ToolsApi
 * @extends {BaseAPI}
 */
export class ToolsApi extends BaseAPI {
    /**
     *
     * @summary Get list of all available tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolsApi
     */
    public toolsGet(options?: RawAxiosRequestConfig) {
        return ToolsApiFp(this.configuration)
            .toolsGet(options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get list of all available tools with statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolsApi
     */
    public toolsInfostatusesGet(options?: RawAxiosRequestConfig) {
        return ToolsApiFp(this.configuration)
            .toolsInfostatusesGet(options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get tools statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolsApi
     */
    public toolsStatusesGet(options?: RawAxiosRequestConfig) {
        return ToolsApiFp(this.configuration)
            .toolsStatusesGet(options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get tool status
     * @param {string} toolid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolsApi
     */
    public toolsStatusesToolidGet(toolid: string, options?: RawAxiosRequestConfig) {
        return ToolsApiFp(this.configuration)
            .toolsStatusesToolidGet(toolid, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get tool extendeed info
     * @param {string} toolid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolsApi
     */
    public toolsToolidGet(toolid: string, options?: RawAxiosRequestConfig) {
        return ToolsApiFp(this.configuration)
            .toolsToolidGet(toolid, options)
            .then(request => request(this.axios, this.basePath));
    }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Login function, takes username and password and returns jwt token
         * @param {string} username
         * @param {string} password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLoginUsernamePasswordGet: async (
            username: string,
            password: string,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists("usersLoginUsernamePasswordGet", "username", username);
            // verify required parameter 'password' is not null or undefined
            assertParamExists("usersLoginUsernamePasswordGet", "password", password);
            const localVarPath = `/users/login/{username}/{password}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"password"}}`, encodeURIComponent(String(password)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary
         * @param {UserPreferencesState} [userPreferencesState]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPreferencesstatePut: async (
            userPreferencesState?: UserPreferencesState,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            const localVarPath = `/users/preferencesstate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                userPreferencesState,
                localVarRequestOptions,
                configuration
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary
         * @param {number} userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPreferencesstateUserIDGet: async (
            userID: number,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists("usersPreferencesstateUserIDGet", "userID", userID);
            const localVarPath = `/users/preferencesstate/{userID}`.replace(
                `{${"userID"}}`,
                encodeURIComponent(String(userID))
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Login function, takes username and password and returns jwt token
         * @param {string} username
         * @param {string} password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersLoginUsernamePasswordGet(
            username: string,
            password: string,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersLoginUsernamePasswordGet(
                username,
                password,
                options
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["UsersApi.usersLoginUsernamePasswordGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary
         * @param {UserPreferencesState} [userPreferencesState]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPreferencesstatePut(
            userPreferencesState?: UserPreferencesState,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPreferencesstatePut(
                userPreferencesState,
                options
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["UsersApi.usersPreferencesstatePut"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary
         * @param {number} userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPreferencesstateUserIDGet(
            userID: number,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferencesState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPreferencesstateUserIDGet(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap["UsersApi.usersPreferencesstateUserIDGet"]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration
                )(axios, localVarOperationServerBasePath || basePath);
        }
    };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration);
    return {
        /**
         *
         * @summary Login function, takes username and password and returns jwt token
         * @param {string} username
         * @param {string} password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLoginUsernamePasswordGet(
            username: string,
            password: string,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<string> {
            return localVarFp
                .usersLoginUsernamePasswordGet(username, password, options)
                .then(request => request(axios, basePath));
        },
        /**
         *
         * @summary
         * @param {UserPreferencesState} [userPreferencesState]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPreferencesstatePut(
            userPreferencesState?: UserPreferencesState,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<boolean> {
            return localVarFp
                .usersPreferencesstatePut(userPreferencesState, options)
                .then(request => request(axios, basePath));
        },
        /**
         *
         * @summary
         * @param {number} userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPreferencesstateUserIDGet(
            userID: number,
            options?: RawAxiosRequestConfig
        ): AxiosPromise<UserPreferencesState> {
            return localVarFp.usersPreferencesstateUserIDGet(userID, options).then(request => request(axios, basePath));
        }
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     *
     * @summary Login function, takes username and password and returns jwt token
     * @param {string} username
     * @param {string} password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersLoginUsernamePasswordGet(username: string, password: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration)
            .usersLoginUsernamePasswordGet(username, password, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary
     * @param {UserPreferencesState} [userPreferencesState]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPreferencesstatePut(userPreferencesState?: UserPreferencesState, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration)
            .usersPreferencesstatePut(userPreferencesState, options)
            .then(request => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPreferencesstateUserIDGet(userID: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration)
            .usersPreferencesstateUserIDGet(userID, options)
            .then(request => request(this.axios, this.basePath));
    }
}
